<!DOCTYPE html>
<meta charset="utf-8">
<style>
svg {
	background-color: #525354;
	max-width: 90vw;		/* 90% of view width */
	max-height: 90vh;		/* 90% of view height */
}
text {
	font-family: sans-serif;
	font-size: 12px;
	fill: #ffffff;
}
circle {
	stroke: none;
	fill: #606162;
}
.instrument path {
	/*stroke: #525354;*/
	/*stroke-width: 1;*/
}
.group path {
	stroke: #ffffff;
	stroke-width: 1;
	fill: none;
}
g.name {
	transform: rotate(-90deg);	/* Align text with angle 0 */
}
.name text {
	text-anchor: end;		/* Horizontal align */
	alignment-baseline: middle;	/* Vertical align */
}
.group text {
	text-anchor: start;
}
.family1 {
	fill: #accf5d;
}
.family2 {
	fill: #e17173;
}
.family3 {
	fill: #65c4be;
}
.family4 {
	fill: #f59640;
}
</style>
<svg viewBox="0 0 500 500">

    <!-- Perform all drawing and calculations from center of SVG -->
    <g transform="translate(250,250)">

        <!-- Add background circle -->
        <circle data-attr-r="{{.|backgroundRadius}}"></circle>

        <!-- Repeat for every instrument -->
        <g data-repeat="{{.}}">

            <!-- Rotate instrument into position (all calculations are relative to angle 0 from here on) -->
            <g class="instrument" data-attr-transform="{{.|rotateInstrument}}">

                <!-- Repeat for every difficulty level -->
                <g data-attr-class="{{.|familyClass}}" data-repeat="{{difficulty|asWedgeArray}}">

                    <!-- Draw single wedge at current difficulty level -->
                    <path data-attr-d="{{.|wedgePath}}"></path>
                </g>

                <!-- Draw instrument name -->
                <g class="name">
                    <text data-attr-x="{{.|textPosition}}" data-attr-transform="{{.|textRotate}}">{{name}}</text>
                </g>
            </g>
        </g>

        <!-- Repeat for every group -->
        <g data-repeat="{{.|groups}}">
            <g class="group">
                <path id="{{id}}" data-attr-d="{{.|groupArc}}"></path>
                <text dy="-10">
                    <!-- Align the following text along the arc above (reference it using xlink:href) -->
                    <!-- Safari needs the xlink namespace to function correctly -->
                    <textPath xlink:data-attr-href='{{.|format: "#{id}"}}' startOffset="50%">{{name}}</textPath>
                </text>
            </g>
        </g>
    </g>
</svg>

<a id="trigger" href="#">Click Me!</a>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://unpkg.com/d3-template-plugin/build/d3-template.js"></script>
<script>
var width = 500;	// viewbox sets fixed width/height
var height = 500;
var margin = {top: 20, right: 20, bottom: 20, left: 20};

// Calculate some sizes
var maxRadius = Math.min(
	(width - margin.left - margin.right) / 2,
	(height - margin.top - margin.bottom) / 2
);
var minLevelRadius = maxRadius * .2;		// At 20% of max radius
var maxLevelRadius = maxRadius * .75;		// At 75% of max radius
var groupRadius = maxRadius * .9;		// At 90% of max radius
var backgroundRadius = maxLevelRadius * 1.05;	// Extend a bit outside level radius
var textPosition = maxLevelRadius * 1.1;	// Extend a bit outside level radius
var groupPaddingAngle = 0.04;

// Read in data and render onto template
d3.csv("instruments.csv", function(error, instruments) {

	// Convert/extract instruments data
	var familyColorIndex = 1;
	var families = {};
	instruments.forEach(function(instrument) {

		// Convert string to integer
		instrument.difficulty = +instrument.difficulty;

		// Give every family unique color index
		if(!families[instrument.family]) {
			families[instrument.family] = familyColorIndex;
			familyColorIndex++;
		}
	});

	// Sort instruments (group first, then family, then name)
	// This assumes a family is always part of the same group
	// (since family specifies color and colors should be next to each other for easthetics)
	instruments.sort(function(a, b) {
		var result = a.group.localeCompare(b.group);
		if(result === 0) {
			result = a.family.localeCompare(b.family);
			if(result === 0) {
				result = a.name.localeCompare(b.name);
			}
		}
		return result;
	});

	// Create scale for radius wedges (donut parts)
	// See band scales: https://github.com/d3/d3-scale#band-scales
	var difficultyExtent = d3.extent(instruments, function(instrument) { return instrument.difficulty; });
	var difficultyRange = d3.range(difficultyExtent[0], difficultyExtent[1] + 1);	// + 1 since 'stop' is not in range
	var radiusScale = d3.scaleBand()
	    .domain(difficultyRange)
	    .range([minLevelRadius, maxLevelRadius])
	    .paddingInner(.2)
	;

	// Create arc generator for wedges (donut parts)
	// See arcs: https://github.com/d3/d3-shape#arcs
	var partWidthInDegress = 360 / instruments.length;
	var partWidthInRadians = 2 * Math.PI / instruments.length;
	var wedgeArcGenerator = d3.arc()
		.startAngle(0)
		.endAngle(partWidthInRadians)
	;

	// Create arc generator for group text
	var groupTextArcGenerator = d3.arc()
		.innerRadius(0)			// This will in fact create pie piece (see "groupArc" filter below for further explanation)
		.outerRadius(groupRadius)
		.padAngle(groupPaddingAngle)
	;

	// Create filters for template
	d3.renderFilter("backgroundRadius", function() {
		// Return background radius (will extent a little beyond max radius for the levels)
		return backgroundRadius;
	});
	d3.renderFilter("rotateInstrument", function(d, i) {
		// Every instrument is rotated into position (from angle 0)
		// Now the wedges and text can be positioned more easily (all start at angle 0)
		return "rotate(" + (partWidthInDegress * i) + ")";
	});
	d3.renderFilter("asWedgeArray", function(d) {
		// Create an array of difficulty levels up to 'actual' difficulty level
		// Difficulty 3 will result in [1, 2, 3]. For every level a wedge will be created.
		return d3.range(1, d + 1);
	});
	d3.renderFilter("wedgePath", function(d) {
		// Create path data for wedge
		// Based on difficulty level the radius of the wedge is specified
		return wedgeArcGenerator({
			innerRadius: radiusScale(d),
			outerRadius: radiusScale(d) + radiusScale.bandwidth()
		});
	});
	d3.renderFilter("textPosition", function(d) {
		// Return text position (will extent a little beyond max radius for the levels)
		return textPosition;
	});
	d3.renderFilter("textRotate", function() {
		// Rotate text so it will be drawn in the middle of the wedge
		return "rotate(" + (partWidthInDegress / 2) + ")";
	});
	d3.renderFilter("familyClass", function(d) {
		// Return class name based on family name
		return "family" + families[d.family];
	});
	d3.renderFilter("groups", function(d) {
		// Create an array of groups. Every group consists of an id, the name of the
		// group, the number of instruments within the group and the start (index)
		// of the group. The count specifies the size of the arc shown 'above' the group.
		// The start index specifies where the arc should start.
		// The id is used to reference the arc (to allow the text to be put onto the arc
		// of the group).
		return d.reduce(function(groups, instrument, i) {

			// Check if current instrument has same group as last time
			if(groups.length > 0 && groups[groups.length - 1].name === instrument.group) {

				// Increase group counter
				groups[groups.length - 1].count++;
			} else {
				// Add new group
				groups.push({
					id: 'group' + groups.length,
					name: instrument.group,
					count: 1,
					start: i
				});
			}

			return groups;
		}, []);
	});
	d3.renderFilter("groupArc", function(d) {
		// Create path data for group arc
		// HACK: Replace everything from first straight line onward. This leaves the
		// single arc 'curve' as data. This hack assumes some knowledge about the
		// way the data is generated and might therefore fail if the arc generator
		// is implemented differently.
		var arcData = groupTextArcGenerator({
			startAngle: d.start * partWidthInRadians,
			endAngle: (d.start + d.count) * partWidthInRadians
		});

		// Replace all line (and other) commands
		arcData = arcData
			.replace(/[Ll][^Aa]*/, "")
		;
		return arcData;
	});

	// Create template and render data onto template
	d3.select("svg")
		.template()
		.render(instruments)
	;

	var chart = d3.select("svg") ;

    d3.select("#trigger").on("click", function() {
        // console.log('got here');
        chart
            .transition() // ALL OF OUR TRANSITIONS WILL GO HERE!
            .attr("x", 250); // Set New Position
    });

});

</script>
